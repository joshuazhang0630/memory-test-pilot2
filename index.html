<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Test - Scientific Visualization</title>
    <style>
        :root {
            --scarlet: #BB0000;
            --scarlet-dark: #990000;
            --dark-gray: #2C2C2C;
            --mid-gray: #666666;
            --light-gray: #F5F5F5;
            --card-border: #E0E0E0;
            --white: #FFFFFF;
            --success: #2E7D32;
            --error: #C62828;
            --warning: #F57C00;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Open Sans", Arial, Helvetica, sans-serif;
            background-color: var(--light-gray);
            color: var(--mid-gray);
            margin: 0;
            min-height: 100vh;
        }

        h1, h2, h3 {
            font-family: "Roboto Slab", Georgia, "Times New Roman", serif;
            color: var(--dark-gray);
            margin-top: 0;
        }

        .osu-banner {
            background-color: var(--scarlet);
            color: var(--white);
            padding: 18px 24px;
            text-align: center;
            font-family: "Roboto Slab", Georgia, serif;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .osu-lockup {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .osu-logo-mark {
            border: 2px solid var(--white);
            border-radius: 3px;
            font-size: 24px;
            padding: 6px 14px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .osu-title {
            font-size: 20px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .osu-subtitle {
            font-size: 14px;
            opacity: 0.85;
        }

        .main-shell {
            max-width: 960px;
            margin: 40px auto;
            padding: 0 20px 60px;
        }

        .card {
            background-color: var(--white);
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 32px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
        }

        .section-title {
            font-size: 34px;
            margin-bottom: 16px;
        }

        .lead-text {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .instruction-list {
            padding-left: 20px;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .instruction-list li {
            margin-bottom: 12px;
        }

        .primary-button {
            background-color: var(--scarlet);
            color: var(--white);
            border: none;
            padding: 12px 40px;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            letter-spacing: 0.05em;
            transition: background-color 0.2s ease;
        }

        .primary-button:hover,
        .primary-button:focus {
            background-color: var(--scarlet-dark);
        }

        .stimulus-panel {
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 24px;
            background-color: var(--white);
        }

        .action-row {
            display: flex;
            justify-content: center;
            margin-top: 24px;
        }

        .stimulus-frame {
            border: 1px solid var(--card-border);
            border-radius: 4px;
            min-height: 360px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--light-gray);
            margin-top: 16px;
        }

        #stimulus {
            max-width: 380px;
            max-height: 340px;
        }

        .instruction-callout {
            font-size: 16px;
            color: var(--dark-gray);
            margin-bottom: 8px;
        }

        .muted-text {
            color: var(--mid-gray);
            font-size: 14px;
        }

        .progress-track {
            width: 100%;
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--scarlet);
            transition: width 0.3s ease;
        }

        .progress-label {
            font-size: 14px;
            color: var(--mid-gray);
            margin-bottom: 16px;
        }

        .time-display {
            font-size: 14px;
            color: var(--dark-gray);
            margin-bottom: 24px;
            font-weight: 600;
        }

        .device-warning {
            text-align: center;
        }

        .feedback-overlay {
            position: fixed;
            top: 24px;
            right: 24px;
            min-width: 240px;
            padding: 16px 20px;
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.1);
            color: var(--white);
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            animation: subtleFade 1.1s ease-out;
            z-index: 1000;
        }

        .feedback-overlay .feedback-icon {
            font-size: 18px;
        }

        .feedback-correct { background-color: var(--success); }
        .feedback-miss { background-color: var(--error); }
        .feedback-false-alarm { background-color: var(--warning); color: var(--dark-gray); }

        @keyframes subtleFade {
            0% { opacity: 0; transform: translateY(-10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }

        .stat-item {
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 16px;
            text-align: center;
        }

        .stat-label {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--mid-gray);
        }

        .stat-value {
            font-size: 26px;
            color: var(--dark-gray);
            margin-top: 8px;
        }

        .irb-note {
            font-size: 14px;
            color: var(--mid-gray);
            margin-top: 16px;
            line-height: 1.5;
        }

        .text-center {
            text-align: center;
        }

        #splash {
            background-color: var(--light-gray);
        }

        .splash-wrapper {
            min-height: calc(100vh - 40px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px 60px;
        }

        .splash-card {
            width: 100%;
            max-width: 520px;
            text-align: left;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--card-border);
            border-radius: 4px;
            font-size: 16px;
            margin: 12px 0 20px;
        }

        .textarea-field {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--card-border);
            border-radius: 4px;
            font-size: 16px;
            margin: 12px 0 20px;
            resize: vertical;
        }

        .question-block {
            margin-bottom: 24px;
        }

        .option-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 12px 0;
        }

        .option-list label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .small-note {
            font-size: 13px;
            color: var(--mid-gray);
        }

        .image-pair {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin: 12px 0 8px;
        }

        .image-choice {
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 10px;
            background: var(--white);
            text-align: center;
        }

        .image-choice img {
            max-width: 100%;
            height: auto;
        }

        .section-divider {
            height: 1px;
            background: var(--card-border);
            margin: 28px 0;
        }
    </style>
</head>
<body>

<!--- Start the Javascript that does all the hard work! --->
<script type="text/javascript" charset="UTF-8">

/* prolific edition
- changed the image set from default to mixed visimages
- modified some variables to suit this experiment better
- added code to feed data into a google sheet via apps script
- added a new mark button to support mobile use
- fixed not allowing continuation upon pressing C while on break
- added splash screens for starting and ending the experiment
- multiple bug fixes

*************** Script by Wilma A. Bainbridge, 2016 ***********************

Updated August 26, 2020: Minor updates:
- Now records responses during fixation
- Fixed bug not showing "goodbye" message
- Uses different (more stable) variable to determine experiment trial length
- Participants now have to press "R" to begin, to ensure correct window focus
----------------------

This script was generated to help you run your memorability experiment based on the parameters you want. I hope this is useful to you! If you use the memorability scores or this script in any of your work, please cite: 

***

I've streamlined how the experiments are run here in comparison to the original Isola et al., 2011 study. This means there are some differences for the sake of making this easier to handle. Major differences include:

- Participants can no longer pause, exit, and start again later (since you'd need to maintain a database of their information somewhere!)
- Breaks are fixed time - participants currently can't continue on their own (because of how Javascript's setTimeout works)
- There is no more practice run. Feel free to make a mini experiment to use as a practice run.
- There is no feedback for button presses.

The output you will get are four variables:
 1. imseq: The order of image files shown to participants. Make sure you have no duplicate file names!! (Even if they're in different directories.)
 2. imtypeseq: The order of trial types.
 		0 = Fixation trial
 		1 = First presentation of a target image
 		2 = Second presentation (target repeat) of a target image
 		3 = First presentation of a filler image
 		4 = Second presentation (vigilance repeat) of a filler image
 3. perfseq: The order of participant behavior for each trial.
 		11 = hit
 		12 = miss
 		13 = false alarm
 		14 = correct rejection
 4. ending: Where the participant ended the study. If they finished, it will be set to "completed". If they failed, it will be set to "failed@" and the percentage of trials completed. If they stopped in the middle, it will be blank (but you will know the number of trials completed by the other variables).
 
One thing to keep in mind is that the most complex part of this script is optimizing the number of targets, fillers, timing, etc to maximize number of memorability scores and minimize the cost of the experiment. I have a beginning formula here that will give a good estimate but there may be more complicated designs you could imagine implementing (for example, adding more vigilance repeats or more target repeats dynamically and intelligently if there are not enough fillers). Feel free to try your hand at this -- you could even hard-code the image sequence yourself here instead of having it automatically calculated if you want complete control over everything!

Also keep in mind that these scripts don't necessarily account for human error. You may need to get more hits than the # calculated because people will often fail / quit in the middle.

Lastly, this script can be used as-is with Amazon Mechanical Turk, but you will have to implement your own server-side saving mechanism if you want to host it on your own website. The main values to save in the database can be find in the hidden input tags near the end of this script. If you'd like a tutorial on this, contact me and I'll write one up for people to use.

Let me know if you'd like anything added / changed: brainbridgelab@gmail.com. I will not be very actively updating these scripts, but if I get enough requests for a feature or change, I will likely implement it!

Additional 2024 updates:
- Added modern splash, instruction, and practice flow with pretrain functionality
- Added inline performance feedback overlays
- Modernized styling and mobile-friendly controls while keeping Bainbridge core logic intact
*/

function osuBanner() {
    return `
        <header class="osu-banner">
            <div class="osu-lockup">
                <div>
                    <div class="osu-title">The Ohio State University</div>
                    <div class="osu-subtitle">Interactive Visual Computing Laboratory</div>
                </div>
            </div>
        </header>
    `;
}

function renderShell(content) {
    return `
        ${osuBanner()}
        <main class="main-shell">
            ${content}
        </main>
    `;
}

function imageLabelFromUrl(url){
    if (!url){
        return "Image";
    }
    var filename = url.substring(url.lastIndexOf("/") + 1);
    return filename.split(".")[0];
}

function pickRandomImagePair(){
    var pool = allImagesCatalog.slice();
    shuffleArray(pool);
    return pool.slice(0, 2);
}

function sampleImagesForPost(count){
    var pool = (images && images.length ? images : allImagesCatalog).slice();
    shuffleArray(pool);
    return pool.slice(0, Math.min(count, pool.length));
}

function renderImageChoice(url, groupName, value){
    var label = imageLabelFromUrl(url);
    return `
        <label class="image-choice">
            <input type="radio" name="${groupName}" value="${value}" required>
            <div><strong>${label}</strong></div>
            <img src="${url}" alt="${label}">
        </label>
    `;
}

function isUnsupportedDevice() {
    var ua = navigator.userAgent || "";
    var mobileRegex = /Mobi|Android|iPhone|iPad|iPod/i;
    return window.innerWidth < 900 || mobileRegex.test(ua);
}

function showDeviceWarning() {
    var warning = `
        <section class="card device-warning">
            <h1 class="section-title">Desktop Device Required</h1>
            <p class="lead-text">
                This study uses keyboard-based responses and must be completed on a laptop or desktop display.
            </p>
            <p class="lead-text">
                Please access the experiment on a larger screen to proceed. Mobile phones and small tablets are not supported.
            </p>
        </section>
    `;
    document.body.innerHTML = renderShell(warning);
}

function enforceDesktopRequirement() {
    if (isUnsupportedDevice()) {
        deviceCompatible = false;
        showDeviceWarning();
    } else {
        deviceCompatible = true;
    }
}

// Load the full image set from the remote manifest so we don't hardcode thousands of URLs.
async function loadImages() {
    const res = await fetch(imageManifestUrl);
    const manifest = await res.json();
    const files = Array.isArray(manifest.files) ? manifest.files : [];
    const base = manifest.baseUrl || "";
    return files.map(function(name){
        return name && name.startsWith("http") ? name : base + name;
    });
}

function ensureImagesLoaded(){
    if (!imageLoadPromise){
        imageLoadPromise = loadImages().then(function(list){
            var pool = list ? list.slice() : [];
            if (pool.length > maxExperimentImages){
                pool = shuffleArray(pool).slice(0, maxExperimentImages);
            }
            images = pool;
            allImagesCatalog = images.slice();
            console.log("Loaded " + images.length + " images from manifest (capped to " + maxExperimentImages + ").");
            return images;
        }).catch(function(err){
            console.error("Failed to load image manifest", err);
            images = [];
            allImagesCatalog = [];
            return [];
        });
    }
    return imageLoadPromise;
}

async function requireImagesReady(){
    await ensureImagesLoaded();
    if (!images.length){
        throw new Error("No images loaded from manifest");
    }
    return images;
}

// parameters set by the experimenter
var fixation_address = "http://www.wilmabainbridge.com/datasets/memorabilitycollector/fixation.jpg";
var imageManifestUrl = "https://ivcl.jiangsn.com/ieee_vis_images/manifest.json";
var images = [];
var allImagesCatalog = [];
var imageLoadPromise = null;
var maxExperimentImages = 120;
var targetProportion = 0.30;
var complexityPair = [];
var preSurveyResponses = {
    workerId: "",
    takenBefore: "",
    gender: "",
    genderSelf: "",
    age: "",
    education: "",
    complexVizDesc: "",
    complexVizLink: "",
    complexityChoice: "",
    complexityImageA: "",
    complexityImageB: ""
};
var postSurveyResponses = {
    rememberedImage: "",
    rememberFeatures: "",
    studyComments: ""
};
var experimentCompleted = false;
var postSurveyVisible = false;
var endingStatus = "";
var stimtime = 2000; // in milliseconds
var isi = 1200; // in milliseconds
var delayBetTargets = 120; // in seconds
var delayBetVigilance = 5; // in trials. The size of image blocks
var keytoWatch = "space"; // use space bar for responses
var subsperim = 40; // how many subjects you want per image
var payperhour = 5; // how much money you want to pay per hour
var vigilancecutoff = 10; // the number of vigilances they're allowed to fail before being booted
var facutoff = 20; // the number of false alarms they're allowed to make before being booted
var timeBetweenBreaks = 300; // in seconds
var maxBreakTime = 15; // in seconds 

// text set by the experimenter
var failuretext = "<h2 class='section-title'>Session Halted</h2><p>You exceeded the permitted error rate. Please submit the session to record participation.</p>";
var donetext = "<h2 class='section-title'>Session Complete</h2><p>Thank you for your diligence. You may now submit the session for credit.</p>";

var deviceCompatible = true;
var totalExperimentDuration = 0;
var experimentStartTimestamp = null;
var timerInterval = null;
var breakCountdownInterval = null;
var breakTimeRemaining = 0;
var breakResumeTimeout = null;

// Pretrain variables
var pretrainImages = []; // Will store indices of images used for pretrain
var pretrainSequence = []; // Full pretrain sequence with repeats
var pretrainTypeSequence = []; // Type of each pretrain trial
var pretrainPerfSequence = []; // Performance for pretrain
var inPretrainMode = false;
var pretrainImCount = -1;
var pretrainHits = 0;
var pretrainMisses = 0;
var pretrainFalseAlarms = 0;
var pretrainCorrectRejections = 0;

// global variables that are calculated later based on parameters
var trialsBetTargets = 30; // in num trials
var numfoils = 0;
var numtargets = 0;
var numtotalsubs = 0;
var allc = 0; // overall sequence counter when building the sequence
var experimentlength = 0;
var paypersub = 0;
var totalpay = 0;
var trialsBetweenBreaks = 0;

// full image sequence variables (these are the whole stream, with fixations built in)
// deal with these for when running the experiment
var fullsequence = []; // the sequence of everything (images plus fixation)
var timesequence = []; // the sequence of the timings
var typesequence = []; // the sequence of the image types
var perfsequence = []; // the sequence of the performance
var breakCounter = 0;
var onBreak = false;

// image-only sequence variables (the ordering without fixation or anything extra you add in)
// deal with these when designing the stimulus presentation
var imtypeseq = []; // the sequence of the image types
var allimgseq = []; // the sequence of all the images
var performanceseq = []; // the sequence of performance
var imCount = -1; // trial number that is being shown. Starts from -1 because of setTimeOut quirks

// tracking performance (to determine if they can continue)
var vigilancefails = 0;
var falsealarmcounts = 0;
var kickedOut = 0;

// output variables
var imgstring = "";
var imtypestring = "";
var perfstring = "";

// ID constants for image type
const FIXATION = 0;
const TARGET = 1;
const REPEAT = 2; // target repeat
const FILLER = 3;
const VIGILANCE = 4; // vigilant repeat

// ID constants for performance
const HIT = 11;
const MISS = 12;
const FALSEALARM = 13;
const CORRECTREJECTION = 14;

/****************************************Functions*****************************************/

// Select pretrain images - 15 images, sampling from each category
function selectPretrainImages() {
    // Image categories (10 of each type)
    var categories = [
        {name: 'text', start: 0, end: 10},
        {name: 'surface', start: 10, end: 20},
        {name: 'point', start: 20, end: 30},
        {name: 'nodelink', start: 30, end: 40},
        {name: 'line', start: 40, end: 50},
        {name: 'grid', start: 50, end: 60},
        {name: 'glyph', start: 60, end: 70},
        {name: 'color', start: 70, end: 80},
        {name: 'bar', start: 80, end: 90},
        {name: 'area', start: 90, end: 100}
    ];
    
    var selected = [];
    
    // Sample 1-2 images from each category to get 15 total
    // First pass: take 1 from each (10 images)
    for (var i = 0; i < categories.length; i++) {
        var cat = categories[i];
        var randomIndex = cat.start + Math.floor(Math.random() * (cat.end - cat.start));
        selected.push(randomIndex);
    }
    
    // Second pass: randomly take 5 more from random categories
    for (var i = 0; i < 5; i++) {
        var randomCat = categories[Math.floor(Math.random() * categories.length)];
        var randomIndex = randomCat.start + Math.floor(Math.random() * (randomCat.end - randomCat.start));
        // Make sure we don't duplicate
        if (selected.indexOf(randomIndex) === -1) {
            selected.push(randomIndex);
        } else {
            i--; // Try again
        }
    }
    
    return selected;
}

// Build pretrain sequence with repeats
function buildPretrainSequence() {
    pretrainImages = selectPretrainImages();
    
    // Shuffle the pretrain images
    pretrainImages = shuffleArray(pretrainImages);
    
    // Build sequence with 3 repeats at intervals of 5-10 images
    var sequence = [];
    var types = [];
    var perf = [];
    
    var repeatIndices = [1, 5, 9]; // Which images to repeat
    var repeatPositions = [6, 14, 19]; // Where to place repeats (after 5, 8, 10 images)
    
    var imgCounter = 0;
    var seqPos = 0;
    
    for (var i = 0; i < 21; i++) { // 15 unique + 3 repeats + some extras = 21 total
        if (repeatPositions.indexOf(i) !== -1) {
            // This is a repeat position
            var whichRepeat = repeatPositions.indexOf(i);
            var imgToRepeat = pretrainImages[repeatIndices[whichRepeat]];
            sequence.push(imgToRepeat);
            types.push(REPEAT);
            perf.push(MISS); // Default: they'll miss it
        } else if (imgCounter < pretrainImages.length) {
            // Regular image
            sequence.push(pretrainImages[imgCounter]);
            types.push(TARGET);
            perf.push(CORRECTREJECTION); // Default: correct rejection
            imgCounter++;
        }
    }
    
    pretrainSequence = sequence;
    pretrainTypeSequence = types;
    pretrainPerfSequence = perf;
    
    console.log("Pretrain sequence built:", pretrainSequence.length, "images");
}

async function showPreSurvey(){
    try {
        await requireImagesReady();
    } catch (e){
        console.error(e);
        var errorView = `
            <section class="card">
                <h1 class="section-title">Unable to load images</h1>
                <p class="lead-text">The image manifest could not be loaded. Please check your network connection and refresh the page.</p>
            </section>
        `;
        document.body.innerHTML = renderShell(errorView);
        return;
    }
    complexityPair = pickRandomImagePair();
    var content = `
        <section class="card">
            <h1 class="section-title">Please tell us a bit about yourself.</h1>
            <p class="lead-text">Fields marked with a * are required.</p>
            <form id="pre-survey-form" autocomplete="off">
                <div class="question-block">
                    <label class="muted-text" for="worker-id-input">Please provide your worker ID if you come from a crowdsourcing platform</label>
                    <input type="text" id="worker-id-input" class="input-field" placeholder="Worker ID (optional)">
                </div>
                <div class="question-block">
                    <label class="muted-text">Have you taken this test before? *</label>
                    <div class="option-list">
                        <label><input type="radio" name="taken-before" value="yes" required>Yes</label>
                        <label><input type="radio" name="taken-before" value="no" required>No</label>
                        <label><input type="radio" name="taken-before" value="unsure" required>Unsure</label>
                    </div>
                </div>
                <div class="question-block">
                    <label class="muted-text">What is your gender? *</label>
                    <div class="option-list">
                        <label><input type="radio" name="gender" value="man" required>Man</label>
                        <label><input type="radio" name="gender" value="woman" required>Woman</label>
                        <label><input type="radio" name="gender" value="non-binary" required>Non-binary</label>
                        <label><input type="radio" name="gender" value="prefer-not" required>Prefer not to disclose</label>
                        <label><input type="radio" name="gender" value="self" required>Prefer to self-describe</label>
                    </div>
                    <input type="text" id="gender-self-input" class="input-field" placeholder="If self-describing, enter here (optional)">
                </div>
                <div class="question-block">
                    <label class="muted-text" for="age-select">How old are you? *</label>
                    <select id="age-select" class="input-field" required>
                        <option value="">Select an age range</option>
                        <option value="0-10">0-10</option>
                        <option value="10-20">10-20</option>
                        <option value="20-30">20-30</option>
                        <option value="30-40">30-40</option>
                        <option value="40-50">40-50</option>
                        <option value="50+">50+</option>
                    </select>
                </div>
                <div class="question-block">
                    <label class="muted-text" for="education-select">What is the highest level of education you have received? *</label>
                    <select id="education-select" class="input-field" required>
                        <option value="">Select one</option>
                        <option value="high-school">High school or equivalent</option>
                        <option value="some-college">Some college</option>
                        <option value="bachelors">Bachelor's degree</option>
                        <option value="masters">Master's degree</option>
                        <option value="phd">PhD or doctoral degree</option>
                        <option value="professional">Professional degree</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div class="question-block">
                    <label class="muted-text" for="complex-desc">Describe the most complex visualization you have ever seen. What does it look like? *</label>
                    <textarea id="complex-desc" class="textarea-field" required placeholder="Describe the visualization"></textarea>
                    <label class="muted-text" for="complex-link">Link to the image (optional)</label>
                    <input type="url" id="complex-link" class="input-field" placeholder="https://">
                </div>
                <div class="question-block">
                    <label class="muted-text">Visual complexity is broadly defined as the level of detail or intricacy contained within an image. Which image feels more visually complex? *</label>
                    <div class="image-pair">
                        ${renderImageChoice(complexityPair[0], "complexity-choice", "A")}
                        ${renderImageChoice(complexityPair[1], "complexity-choice", "B")}
                    </div>
                    <div class="small-note">Pick the option you feel strongest about.</div>
                </div>
                <div class="action-row">
                    <button type="submit" class="primary-button">Continue to Instructions</button>
                </div>
            </form>
        </section>
    `;
    document.body.innerHTML = renderShell(content);

    var workerInput = document.getElementById("worker-id-input");
    if (workerInput && pid){
        workerInput.value = pid;
    }

    var preForm = document.getElementById("pre-survey-form");
    if (preForm){
        preForm.onsubmit = function(e){
            e.preventDefault();
            preSurveyResponses.workerId = (document.getElementById("worker-id-input").value || "").trim();
            preSurveyResponses.takenBefore = (document.querySelector("input[name='taken-before']:checked") || {}).value || "";
            preSurveyResponses.gender = (document.querySelector("input[name='gender']:checked") || {}).value || "";
            preSurveyResponses.genderSelf = (document.getElementById("gender-self-input").value || "").trim();
            preSurveyResponses.age = document.getElementById("age-select").value;
            preSurveyResponses.education = document.getElementById("education-select").value;
            preSurveyResponses.complexVizDesc = (document.getElementById("complex-desc").value || "").trim();
            preSurveyResponses.complexVizLink = (document.getElementById("complex-link").value || "").trim();
            preSurveyResponses.complexityChoice = (document.querySelector("input[name='complexity-choice']:checked") || {}).value || "";
            preSurveyResponses.complexityImageA = complexityPair[0];
            preSurveyResponses.complexityImageB = complexityPair[1];

            buildPretrainSequence();
            showInstructions();
        };
    }
}

// Show instruction page
function showInstructions() {
    var content = `
        <section class="card">
            <p class="lead-text">
                During this study you will evaluate visualizations and indicate when an image repeats <strong>within the current block</strong>.
            </p>
            <ol class="instruction-list">
                <li><strong>Attend carefully.</strong> Each visualization appears for 1 second followed by a fixation interval.</li>
                <li><strong>Respond only to repeats.</strong> Press the <strong>SPACE BAR</strong> as soon as you recognize a repeated image in the active block.</li>
                <li><strong>Remain focused.</strong> Repeats may occur long after first exposure and can closely resemble other images.</li>
            </ol>
            <p class="lead-text">
                Performance monitoring: the system tracks <strong>false alarms</strong> (responding to new images) and <strong>vigilance misses</strong>
                (missing scheduled repeats). The session ends if you exceed ${facutoff} false alarms or ${vigilancecutoff} vigilance misses.
            </p>
            <p class="lead-text">
                We begin with a short practice block to ensure the procedure is clear. Practice data are not stored, and all responses
                in both practice and the primary experiment must be made with the <strong>SPACE BAR</strong>.
            </p>
            <div class="action-row">
                <button class="primary-button" onclick="startPretrain()">Begin Practice Block</button>
            </div>
        </section>
    `;
    document.body.innerHTML = renderShell(content);
}

// Start pretrain
function startPretrain() {
	inPretrainMode = true;
	pretrainImCount = -1;
	
    // Reset counters
	pretrainHits = 0;
	pretrainMisses = 0;
	pretrainFalseAlarms = 0;
	pretrainCorrectRejections = 0;
	
	var practiceView = `
		<section class="card">
			<h1 class="section-title">Practice Block</h1>
			<p class="lead-text">
				During practice, respond only when a visualization repeats within this practice block. Use the <strong>SPACE BAR</strong> to register detections.
			</p>
			<div class="stimulus-panel">
				<div id="performancerecord" class="instruction-callout">
					Press SPACE to begin the practice sequence.
				</div>
				<div class="stimulus-frame">
					<img id="stimulus" src="${fixation_address}" alt="Practice stimulus">
				</div>
			</div>
			<p class="muted-text">Keyboard input required: SPACE BAR only.</p>
		</section>
	`;
	document.body.innerHTML = renderShell(practiceView);
}

// Animate pretrain sequence
function animatePretrainSequence() {
    pretrainImCount++;
    
    if (pretrainImCount >= pretrainSequence.length * 2) { // *2 because we have fixations
        // Pretrain finished
        showPretrainResults();
        return;
    }
    
    // Determine if it's an image or fixation
    var isImage = (pretrainImCount % 2 === 0);
    
    if (isImage) {
        var imgIndex = Math.floor(pretrainImCount / 2);
        document.getElementById("stimulus").src = images[pretrainSequence[imgIndex]];
        setTimeout("animatePretrainSequence()", stimtime);
    } else {
        document.getElementById("stimulus").src = fixation_address;
        setTimeout("animatePretrainSequence()", isi);
    }
}

// Show feedback for pretrain
function showPretrainFeedback(type) {
	var feedback = document.createElement('div');
	feedback.className = 'feedback-overlay feedback-' + type;
	
	var icon = '';
	var message = '';
	if (type === 'correct') {
		icon = '✓';
		message = 'Repeat detected';
	} else if (type === 'miss') {
		icon = '✗';
		message = 'Repeat missed';
	} else if (type === 'false-alarm') {
		icon = '⚠';
		message = 'False alarm on novel image';
	}
	feedback.innerHTML = `<span class="feedback-icon">${icon}</span><span>${message}</span>`;
	
	document.body.appendChild(feedback);
	
    setTimeout(function() {
        document.body.removeChild(feedback);
    }, 1000);
}

// Process pretrain response
function processPretrainResponse() {
    if (pretrainImCount < 0) {
        // Start the pretrain
        document.getElementById("performancerecord").innerHTML = "";
        animatePretrainSequence();
        return;
    }
    
    var isImage = (pretrainImCount % 2 === 0);
    if (!isImage && pretrainImCount > 0) {
        // They pressed during fixation, check previous image
        var imgIndex = Math.floor((pretrainImCount - 1) / 2);
        var trialType = pretrainTypeSequence[imgIndex];
        
        if (trialType === REPEAT) {
            // Hit!
            pretrainPerfSequence[imgIndex] = HIT;
            pretrainHits++;
            showPretrainFeedback('correct');
        } else {
            // False alarm
            pretrainPerfSequence[imgIndex] = FALSEALARM;
            pretrainFalseAlarms++;
            showPretrainFeedback('false-alarm');
        }
    } else if (isImage) {
        var imgIndex = Math.floor(pretrainImCount / 2);
        var trialType = pretrainTypeSequence[imgIndex];
        
        if (trialType === REPEAT) {
            // Hit!
            pretrainPerfSequence[imgIndex] = HIT;
            pretrainHits++;
            showPretrainFeedback('correct');
        } else {
            // False alarm
            pretrainPerfSequence[imgIndex] = FALSEALARM;
            pretrainFalseAlarms++;
            showPretrainFeedback('false-alarm');
        }
    }
}

// Show pretrain results
function showPretrainResults() {
	// Count misses and correct rejections
	for (var i = 0; i < pretrainPerfSequence.length; i++) {
        if (pretrainPerfSequence[i] === MISS) {
            pretrainMisses++;
        } else if (pretrainPerfSequence[i] === CORRECTREJECTION) {
            pretrainCorrectRejections++;
        }
    }
    
    var totalRepeats = 3;
    var accuracy = Math.round((pretrainHits / totalRepeats) * 100);
    
	var summaryView = `
		<section class="card">
			<h1 class="section-title">Practice Summary</h1>
			<p class="lead-text">
				The calibration block is complete. Review your performance below before advancing to the primary session.
			</p>
			<div class="stats-grid">
				<div class="stat-item">
					<div class="stat-label">Repeats Detected</div>
					<div class="stat-value">${pretrainHits} / ${totalRepeats}</div>
				</div>
				<div class="stat-item">
					<div class="stat-label">Accuracy</div>
					<div class="stat-value">${accuracy}%</div>
				</div>
				<div class="stat-item">
					<div class="stat-label">False Alarms</div>
					<div class="stat-value">${pretrainFalseAlarms}</div>
				</div>
			</div>
			<p class="lead-text">
				Respond only when the visualization is identical to one seen earlier within the <strong>current game</strong>, and continue using the <strong>SPACE BAR</strong> for every response.
				After you continue, all practice images are removed and do not influence the primary experiment.
			</p>
			<div class="action-row">
				<button class="primary-button" onclick="startRealExperiment()">Continue to Experiment</button>
			</div>
		</section>
	`;
	document.body.innerHTML = renderShell(summaryView);
}

// Start real experiment
function startRealExperiment() {
	inPretrainMode = false;
	stopExperimentTimer();
	experimentStartTimestamp = null;
    
    // Remove pretrain images from the main image array
    var newImages = [];
    for (var i = 0; i < images.length; i++) {
        if (pretrainImages.indexOf(i) === -1) {
            newImages.push(images[i]);
        }
    }
    images = newImages;
    
	console.log("Starting real experiment with", images.length, "images");
	
	var interfaceView = `
		<form id="form" class="card" autocomplete="off">
			<input type="hidden" name="imseq" id="imseqout" value="">
			<input type="hidden" name="imtypeseq" id="imtypeseqout" value="">
			<input type="hidden" name="perfseq" id="perfseqout" value="">
			<input type="hidden" name="ending" id="endingout" value="">

			<h1 class="section-title">Visual Memorability Assessment</h1>
			<p class="lead-text">
				Press the <strong>SPACE BAR</strong> whenever you detect an exact repeat of a visualization in this <strong>current game</strong>.
				Images from the practice block have been removed and will not appear here. Avoid responses during fixation intervals.
			</p>
			<div class="progress-track" aria-hidden="false">
				<div class="progress-bar" id="experiment-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
			</div>
			<div id="progress-label" class="progress-label">Progress 0%</div>
			<div id="time-display" class="time-display" aria-live="polite">Elapsed 00:00 • Approx. remaining --:--</div>
			<div class="stimulus-panel">
				<div id="performancerecord" class="instruction-callout">
					Press the SPACE BAR to initiate the sequence. Ensure this window has keyboard focus.
				</div>
				<div class="stimulus-frame">
					<img id="stimulus" src="${fixation_address}" alt="Stimulus image">
				</div>
			</div>
			<p class="muted-text">
				Error monitoring: exceeding ${facutoff} total false alarms or ${vigilancecutoff} missed vigilance repeats will end the session early.
			</p>
			<p class="irb-note">
				By continuing you confirm your voluntary participation in an OSU-approved research protocol. Please complete the entire block before submitting.
			</p>
			<p class="muted-text text-center">Post-study questions will appear automatically once the session ends.</p>
		</form>
	`;
	document.body.innerHTML = renderShell(interfaceView);
	
	// Setup form submission
	document.getElementById("form").onsubmit = function(e){
		e.preventDefault();
		if (!postSurveyVisible){
			document.getElementById("performancerecord").innerHTML = "Please finish the experiment; post-study questions will appear automatically.";
		}
	};
	
	// Now preload and start the real experiment
	preloadEverything();
	updateExperimentProgress();
}

// key press listener
document.onkeydown = function(key){ 
	if (!deviceCompatible){
		return;
	}
    if (inPretrainMode) {
        if (isSpaceKey(key)) {
            key.preventDefault();
            processPretrainResponse();
        }
    } else {
        if (isResponseKey(key)){
            key.preventDefault();
            processResponse(key);
        }
    }
};

document.addEventListener('keydown', function(event) {
	if (!deviceCompatible){
		return;
	}
    if (onBreak && event.key && event.key.toLowerCase() === 'c') {
        giveBreak(1);
    }
});

// preload and then start
async function buttonPress(){
	document.getElementById("startbutton").innerHTML = "Experiment Running...";
	document.getElementById("startbutton").disabled = true;
	await ensureImagesLoaded();
	if (!images.length){
		document.getElementById("performancerecord").innerHTML = "Unable to load images from the manifest. Please refresh and try again.";
		document.getElementById("startbutton").disabled = false;
		return;
	}
	preloadEverything();
	document.getElementById("performancerecord").innerHTML = "Press the <b>SPACE BAR</b> to start. If it doesn't work, make sure to click in this browser window first.";
}

// recursive function that shows the images in a sequence
function animateSequence(){
	saveProgress();
	
	determineFailure();
	if (kickedOut){
		showFailure();
		return;
	}
	
	if (breakCounter >= trialsBetweenBreaks) {
		giveBreak(0);
		breakCounter = -1;
		return;
	}
	breakCounter++;
	
	imCount++;
	updateExperimentProgress();
	if (imCount == fullsequence.length){
		showEnding();
		return;
	}
	document.getElementById("stimulus").src = fullsequence[imCount];
	
	setTimeout("animateSequence()", timesequence[imCount]);
}

// preload and calculate everything
function preloadEverything() {
	calculateProps();
	makeImSequence();
	calculateTotalPay();
	buildFullSequence();
}

// allows the participant to take a break
function giveBreak(going){
	if (going){
		onBreak = false;
		if (breakCountdownInterval){
			clearInterval(breakCountdownInterval);
			breakCountdownInterval = null;
		}
		if (breakResumeTimeout){
			clearTimeout(breakResumeTimeout);
			breakResumeTimeout = null;
		}
		document.getElementById("performancerecord").innerHTML = '';
		setTimeout(function(){ animateSequence(); }, timesequence[imCount]);
		return;
	}
	onBreak = true;
	document.getElementById("stimulus").src = fixation_address;
	breakTimeRemaining = maxBreakTime;
	document.getElementById("performancerecord").innerHTML = '<h2>Break time!</h2>Good job - you will now get a break. You have <span id="break-countdown">' + breakTimeRemaining + '</span> seconds remaining before the task resumes automatically. Press "<b>C</b>" to continue sooner.';
	
	if (breakCountdownInterval){
		clearInterval(breakCountdownInterval);
	}
	breakCountdownInterval = setInterval(function(){
		breakTimeRemaining = Math.max(0, breakTimeRemaining - 1);
		var span = document.getElementById("break-countdown");
		if (span){
			span.textContent = breakTimeRemaining;
		}
		if (breakTimeRemaining <= 0){
			clearInterval(breakCountdownInterval);
			breakCountdownInterval = null;
		}
	}, 1000);
	
	if (breakResumeTimeout){
		clearTimeout(breakResumeTimeout);
	}
	breakResumeTimeout = setTimeout(function(){
		giveBreak(1);
	}, maxBreakTime*1000);
}

// builds the full sequence with both images and fixations, as well as timings
function buildFullSequence(){
	var i = 0;
	var imcounter = 0;
	while (i < imtypeseq.length*2){
		fullsequence[i] = images[allimgseq[imcounter]];
		typesequence[i] = imtypeseq[imcounter];
		timesequence[i] = stimtime;
		perfsequence[i] = performanceseq[imcounter];
		i++;
		imcounter++;
		
		fullsequence[i] = fixation_address;
		typesequence[i] = FIXATION;
		timesequence[i] = isi;
		perfsequence[i] = FIXATION;
		i++;
	}
	console.log("Done building the full sequence.");
	totalExperimentDuration = timesequence.reduce(function(total, value){ return total + value; }, 0);
}

function updateExperimentProgress(){
	var bar = document.getElementById("experiment-progress");
	var label = document.getElementById("progress-label");
	if (!bar || fullsequence.length === 0){
		return;
	}
	var completed = 0;
	if (imCount >= fullsequence.length){
		completed = fullsequence.length;
	} else if (imCount >= 0){
		completed = imCount + 1;
	}
	var percent = Math.min(100, (completed / fullsequence.length) * 100);
	bar.style.width = percent + "%";
	bar.setAttribute("aria-valuenow", percent.toFixed(1));
	if (label){
		label.textContent = "Progress " + Math.round(percent) + "%";
	}
	updateTimerDisplay();
}

function formatTimer(ms){
	var totalSeconds = Math.max(0, Math.floor(ms / 1000));
	var minutes = Math.floor(totalSeconds / 60);
	var seconds = totalSeconds % 60;
	return String(minutes).padStart(2, "0") + ":" + String(seconds).padStart(2, "0");
}

function updateTimerDisplay(){
	var display = document.getElementById("time-display");
	if (!display){
		return;
	}
	if (!experimentStartTimestamp || totalExperimentDuration === 0){
		display.textContent = "Elapsed 00:00 • remaining --:--";
		return;
	}
	var elapsed = Date.now() - experimentStartTimestamp;
	var remaining = Math.max(0, totalExperimentDuration - elapsed);
	display.textContent = "Elapsed " + formatTimer(elapsed) + " remaining " + formatTimer(remaining);
}

function startExperimentTimer(){
	if (!experimentStartTimestamp){
		experimentStartTimestamp = Date.now();
	}
	if (timerInterval){
		return;
	}
	updateTimerDisplay();
	timerInterval = setInterval(updateTimerDisplay, 1000);
}

function stopExperimentTimer(){
	if (timerInterval){
		clearInterval(timerInterval);
		timerInterval = null;
	}
}

function isSpaceKey(event){
	if (!event){
		return false;
	}
	if (event.code && event.code.toLowerCase() === "space"){
		return true;
	}
	if (event.key){
		var keyName = event.key.toLowerCase();
		if (keyName === " " || keyName === "spacebar" || keyName === "space"){
			return true;
		}
	}
	if (event.keyCode){
		return event.keyCode === 32;
	}
	return false;
}

function isResponseKey(event){
	if (keytoWatch === "space"){
		return isSpaceKey(event);
	}
	var pressed = event.key ? event.key.toLowerCase() : String.fromCharCode(event.keyCode).toLowerCase();
	return pressed === keytoWatch.toLowerCase();
}

// get the key and respond
function processResponse(key){
	if(isResponseKey(key)){
		var trialtype = typesequence[imCount];
		if (imCount<0) {
			document.getElementById("performancerecord").innerHTML = "";
			if (!inPretrainMode){
				startExperimentTimer();
			}
			animateSequence();
		}
		if ((trialtype == FIXATION) && imCount > 0) {
			trialtype = typesequence[imCount-1];
		}
		if (trialtype == REPEAT | trialtype == VIGILANCE) {
			perfsequence[imCount] = HIT;
			console.log("Hit!");
		} else if (trialtype == TARGET | trialtype == FILLER) {
			perfsequence[imCount] = FALSEALARM;
			console.log("False alarm!");
		}
	}
}

// decide if they've failed too much
function determineFailure(){
	if (perfsequence[imCount] == FALSEALARM){
		falsealarmcounts++;
		console.log("False alarm count: " + falsealarmcounts);
	}
	if (falsealarmcounts >= facutoff){
		kickedOut = 1;
	}
	
	if (perfsequence[imCount] == MISS & typesequence[imCount] == VIGILANCE){
		vigilancefails++;
		console.log("Vigilance miss count: " + vigilancefails);
	}
	if (vigilancefails >= vigilancecutoff){
		kickedOut = 1;
	}
}

function showPostSurvey(){
	if (postSurveyVisible){
		return;
	}
	postSurveyVisible = true;
	saveProgress();
	stopExperimentTimer();
	var rememberedSample = sampleImagesForPost(4);
	var rememberedHtml = rememberedSample.map(function(url){
		return renderImageChoice(url, "remembered-image", url);
	}).join("");
	var content = `
		<form id="form" class="card" autocomplete="off">
			<input type="hidden" name="imseq" id="imseqout" value="">
			<input type="hidden" name="imtypeseq" id="imtypeseqout" value="">
			<input type="hidden" name="perfseq" id="perfseqout" value="">
			<input type="hidden" name="ending" id="endingout" value="">
			<input type="hidden" name="post_image_options" id="post-image-options" value="">

			<h1 class="section-title">Post-study questions</h1>
			<div class="question-block">
				<label class="muted-text">Pick a picture you remember correctly from the game and tell us what helped you remember it. *</label>
				<div class="image-pair">
					${rememberedHtml}
				</div>
				<textarea id="remember-features" name="remember_features" class="textarea-field" required placeholder="Describe the feature(s) that helped you remember."></textarea>
			</div>
			<div class="question-block">
				<label class="muted-text" for="study-comments">What comments do you have about the study?</label>
				<textarea id="study-comments" name="study_comments" class="textarea-field" placeholder="Optional feedback"></textarea>
			</div>
			<div class="action-row">
				<button type="submit" class="primary-button">Submit Session</button>
			</div>
		</form>
	`;
	document.body.innerHTML = renderShell(content);

	var imseqInput = document.getElementById("imseqout");
	var imtypeInput = document.getElementById("imtypeseqout");
	var perfInput = document.getElementById("perfseqout");
	var endingInput = document.getElementById("endingout");
	var postOptionsInput = document.getElementById("post-image-options");
	if (imseqInput){ imseqInput.value = imgstring; }
	if (imtypeInput){ imtypeInput.value = imtypestring; }
	if (perfInput){ perfInput.value = perfstring; }
	if (endingInput){ endingInput.value = endingStatus || "completed"; }
	if (postOptionsInput){ postOptionsInput.value = rememberedSample.join(","); }

	var postForm = document.getElementById("form");
	if (postForm){
		postForm.onsubmit = function(e){
			e.preventDefault();
			postSurveyResponses.rememberedImage = (document.querySelector("input[name='remembered-image']:checked") || {}).value || "";
			postSurveyResponses.rememberFeatures = (document.getElementById("remember-features").value || "").trim();
			postSurveyResponses.studyComments = (document.getElementById("study-comments").value || "").trim();
			sendToSheets();
			var thanks = `
				<section class="card text-center">
					<h1 class="section-title">Submission Received</h1>
					<p class="lead-text">Thank you for supporting the Computer Vision Lab. Your responses have been securely recorded.</p>
					<p class="irb-note">You may now close this window.</p>
				</section>
			`;
			document.body.innerHTML = renderShell(thanks);
		};
	}
}

// visually show their failure!
function showFailure(){
	stopExperimentTimer();
	document.getElementById("performancerecord").innerHTML = failuretext;
	propcompleted = imCount/fullsequence.length*100;
	propcompleted = propcompleted.toFixed(2);
	endingStatus = "failed@" + propcompleted + "%";
	var endingInput = document.getElementById("endingout");
	if (endingInput){
		endingInput.value = endingStatus;
	}
	experimentCompleted = true;
	showPostSurvey();
}

// end the game if they make it to the end!
function showEnding(){
	stopExperimentTimer();
	experimentCompleted = true;
	endingStatus = "completed";
	var endingInput = document.getElementById("endingout");
	if (endingInput){
		endingInput.value = endingStatus;
	}
	document.getElementById("performancerecord").innerHTML = donetext;
	showPostSurvey();
}

// create the memorability-based image sequence
function makeImSequence(){
	var allImArray = populateArray(0, images.length);
	allImArray = shuffleArray(allImArray);
	var targetIms = allImArray.slice(0, numtargets);
	var fillerIms = allImArray.slice(numtargets, allImArray.length);
	var imblock = [];
	var typeblock = [];
	var perfblock = [];

	targetIms = shuffleArray(targetIms);
	repeatIms = shuffleArray(targetIms);
	fillerIms = shuffleArray(fillerIms);
	
	tc = 0;
	fc = 0;
	ofbc = 0;
	rc = 0;
	allc = 0;
	
	oldfillblock = [];
	
	while (rc < repeatIms.length & fc < fillerIms.length){
		var c = 0;
		
		if (tc < targetIms.length) {
			imblock[c] = targetIms[tc]; 
			typeblock[c] = TARGET;
			perfblock[c] = CORRECTREJECTION;
			tc++; c++; allc++;
		} else {
			imblock[c] = fillerIms[fc];
			typeblock[c] = FILLER;
			perfblock[c] = CORRECTREJECTION;
			oldfillblock[ofbc] = fillerIms[fc];
			c++; allc++; ofbc++; fc++;
		}
	
		if (oldfillblock.length > 0) {
			oldfillblock = shuffleArray(oldfillblock);
			imblock[c] = oldfillblock[0];
			typeblock[c] = VIGILANCE;
			perfblock[c] = MISS;
			c++; allc++;
			oldfillblock = []; ofbc = 0;
		} else {
			imblock[c] = fillerIms[fc];
			typeblock[c] = FILLER;
			perfblock[c] = CORRECTREJECTION;
			oldfillblock[ofbc] = fillerIms[fc]; 
			c++; allc++; ofbc++; fc++;
		}
	
		if (allc > trialsBetTargets) {
			imblock[c] = repeatIms[rc];
			typeblock[c] = REPEAT;
			perfblock[c] = MISS;
			rc++; c++; allc++;
		} else{
			imblock[c] = fillerIms[fc];
			typeblock[c] = FILLER;
			perfblock[c] = CORRECTREJECTION;
			oldfillblock[ofbc] = fillerIms[fc]; 
			c++; allc++; ofbc++; fc++;
		}
	
		for (var i = 0; i < delayBetVigilance-3; i++){
			if (fc < fillerIms.length) {
				imblock[c] = fillerIms[fc]; 
				typeblock[c] = FILLER;
				perfblock[c] = CORRECTREJECTION;
				oldfillblock[ofbc] = fillerIms[fc];
				c++; allc++; ofbc++; fc++;
			}
		}
		
		[imblock, typeblock, perfblock] = shuffleArrays([imblock, typeblock, perfblock]);
		
		allimgseq = allimgseq.concat(imblock);
		imtypeseq = imtypeseq.concat(typeblock);
		performanceseq = performanceseq.concat(perfblock);
	
	}
	
	console.log("Done making the image sequence!");
}

// calculate the proportions of targets and foils
function calculateProps(){
	var trialtime = stimtime + isi;
	trialsBetTargets = Math.floor(delayBetTargets*1000 / trialtime);
	var totalImages = images.length;
	numtargets = Math.max(1, Math.round(totalImages * targetProportion));
	numfoils = Math.max(0, totalImages - numtargets);
	
	trialsBetweenBreaks = Math.ceil(timeBetweenBreaks*1000/trialtime);
	
	console.log("Calculated fixed proportions: " + numtargets + " targets and " + numfoils + " fillers out of " + totalImages + " images.");
}

// calculate the total pay for the whole study
function calculateTotalPay(){
	var proptargets = images.length / numtargets;
	numtotalsubs = proptargets * subsperim;
	
	experimentlength = (allc * (stimtime + isi)/1000)/60;
	paypersub = experimentlength/60 * payperhour;
	totalpay = paypersub * numtotalsubs;
	
	console.log("Calculated the pay amounts.");
}

function reportVariables(){
	var report = " With your " + images.length + " total images, if you want " + delayBetTargets + "s between target images,\n You will need " + numtargets + " targets and " + numfoils + " foils.\n This will result in an experiment that is " + experimentlength + "min long.\n To get " + subsperim + " subjects per target image, you will need " + numtotalsubs + " total subjects.\n At a rate of $" + payperhour + " per hour, each experiment will cost $" + paypersub + ",\n Or $" + totalpay + " for the whole study.";
	
	console.log(report);
}

// save to the output variables the performance and sequence completed so far
function saveProgress(){
	if (imCount >= 0) {
		var tempimg = fullsequence[imCount];
		tempimg = tempimg.substring(tempimg.lastIndexOf("/")+1);
		if (imCount > 0) {
			imgstring = imgstring + ",";
			imtypestring = imtypestring + ",";
			perfstring = perfstring + ",";
		}
		imgstring = imgstring + tempimg;
		imtypestring = imtypestring + typesequence[imCount];
		perfstring = perfstring + perfsequence[imCount];
		document.getElementById("imseqout").value = imgstring;
		document.getElementById("imtypeseqout").value = imtypestring;
		document.getElementById("perfseqout").value = perfstring;
	}
}

/*************************************** General useful functions **********************************************/

function populateArray(start, end){
	array = [];
	for (var i = start; i < end; i++){
		array[i] = i;
	}
	return array;
}

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}

function shuffleArrays(arrays){
	for (var i = arrays[0].length - 1; i > 0; i--) {
		var j = Math.floor(Math.random() * (i + 1));
		for (var an = 0; an < arrays.length; an++) {
			var temp = arrays[an][i];
			arrays[an][i] = arrays[an][j];
			arrays[an][j] = temp;
		}
	}
	return arrays;
}
			
function countOccurences(array, value){
	var counter = 0;
	for (var i = 0; i < array.length; i++){
		if (array[i] == value){
			counter++;
		}
	}
	return counter;
}

function sendToSheets() {
	const form = document.getElementById('form');
    const formData = new FormData(form);
    const data = {
		prolific_id: pid,
		imseq: imgstring,
        imtypeseq: imtypestring,
        perfseq: perfstring,
        ending: document.getElementById("endingout").value,
        vigilancefails: vigilancefails,
        falsealarmcounts: falsealarmcounts,
        pre_worker_id: preSurveyResponses.workerId,
        pre_taken_before: preSurveyResponses.takenBefore,
        pre_gender: preSurveyResponses.gender,
        pre_gender_self: preSurveyResponses.genderSelf,
        pre_age: preSurveyResponses.age,
        pre_education: preSurveyResponses.education,
        pre_complex_viz_desc: preSurveyResponses.complexVizDesc,
        pre_complex_viz_link: preSurveyResponses.complexVizLink,
        pre_complexity_choice: preSurveyResponses.complexityChoice,
        pre_complexity_image_a: preSurveyResponses.complexityImageA,
        pre_complexity_image_b: preSurveyResponses.complexityImageB,
        post_remembered_image: postSurveyResponses.rememberedImage,
        post_remember_features: postSurveyResponses.rememberFeatures,
        post_study_comments: postSurveyResponses.studyComments
	};
	const appsURL = "https://script.google.com/macros/s/AKfycbwkzZhSsUOV_AMEQuLcLTKU2nohE-JdN5Lu-mDfZ-JFvBKLNMZS7_77FK-9Qf8VdpSCDQ/exec";
    
    for (let [key, value] of formData.entries()) {
        data[key] = value;
    }

    data.vigilancefails = vigilancefails;
    data.falsealarmcounts = falsealarmcounts;

    console.log("data", data);

    fetch(appsURL, {
        method: "POST",
		mode: "no-cors",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(data)
    }).then(() => {
        console.log("Data sent to Google Sheets!");
    }).catch(err => console.error("Error:", err));
}

// Initialize - show splash screen first
var pid = '';
</script>

<div id="splash">
	<div class="osu-banner">
		<div class="osu-lockup">
			<div>
				<div class="osu-title">The Ohio State University</div>
				<div class="osu-subtitle">Interactive Visual Computing Laboratory</div>
			</div>
		</div>
	</div>
	<div class="splash-wrapper">
		<div class="splash-card card">
			<form id="prolific-form">
				<p class="lead-text">
					Please enter your Prolific ID (or OSU participant ID) to begin. We will walk you through the pretrain progress first before you take the task. The study lasts approximately five minutes.
				</p>
				<label for="prolific-id-input" class="muted-text">Participant ID</label>
				<input type="text" id="prolific-id-input" name="prolific_id" class="input-field" required placeholder="Enter ID">
				<div class="action-row">
					<button type="submit" class="primary-button">Begin</button>
				</div>
			</form>
		</div>
	</div>
</div>

<script>
	document.addEventListener('DOMContentLoaded', function(){
		enforceDesktopRequirement();
		ensureImagesLoaded();
		if (!deviceCompatible){
			return;
		}
		var form = document.getElementById('prolific-form');
		if (!form){
			return;
		}
		form.onsubmit = async function(e) {
			e.preventDefault();
			enforceDesktopRequirement();
			if (!deviceCompatible){
				return;
			}
			await ensureImagesLoaded();
			pid = document.getElementById('prolific-id-input').value.trim();
			if(pid) {
				document.getElementById('splash').style.display = 'none';
				
				// Go to demographics & pre-questions
				showPreSurvey();
			}
		};
	});
</script>
</body>
</html>
